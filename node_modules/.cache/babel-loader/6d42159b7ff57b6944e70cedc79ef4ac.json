{"ast":null,"code":"////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2021 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\nconst {\n  symbols\n} = require(\"@realm/common\");\n\nlet getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function (obj) {\n  return Object.getOwnPropertyNames(obj).reduce(function (descriptors, name) {\n    descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n    return descriptors;\n  }, {});\n};\n\nfunction setConstructorOnPrototype(klass) {\n  if (klass.prototype.constructor !== klass) {\n    Object.defineProperty(klass.prototype, \"constructor\", {\n      value: klass,\n      configurable: true,\n      writable: true\n    });\n  }\n}\n\nfunction openLocalRealm(realmConstructor, config) {\n  let promise = Promise.resolve(new realmConstructor(config));\n\n  promise.progress = () => {\n    return promise;\n  };\n\n  promise.cancel = () => {};\n\n  return promise;\n}\n\nmodule.exports = function (realmConstructor) {\n  // Add the specified Array methods to the Collection prototype.\n  Object.defineProperties(realmConstructor.Set.prototype, require(\"./set-methods\")(realmConstructor));\n  Object.defineProperties(realmConstructor.Collection.prototype, require(\"./collection-methods\")(realmConstructor));\n  realmConstructor.DictionaryProxy = require(\"./dictionary\").DictionaryProxy;\n  setConstructorOnPrototype(realmConstructor.Collection);\n  setConstructorOnPrototype(realmConstructor.List);\n  setConstructorOnPrototype(realmConstructor.Results);\n  setConstructorOnPrototype(realmConstructor.Object);\n  setConstructorOnPrototype(realmConstructor.Set);\n  setConstructorOnPrototype(realmConstructor.DictionaryProxy);\n  realmConstructor.BSON = require(\"bson\");\n  realmConstructor._Decimal128 = realmConstructor.BSON.Decimal128;\n  realmConstructor._ObjectId = realmConstructor.BSON.ObjectId;\n  realmConstructor._UUID = realmConstructor.BSON.UUID;\n\n  const {\n    DefaultNetworkTransport\n  } = require(\"@realm/network-transport\");\n\n  realmConstructor._networkTransport = new DefaultNetworkTransport(); // Adds to cache when serializing an object for toJSON\n\n  const addToCache = (cache, realmObj, value) => {\n    const tableKey = realmObj._tableKey();\n\n    let cachedMap = cache.get(tableKey);\n\n    if (!cachedMap) {\n      cachedMap = new Map();\n      cache.set(tableKey, cachedMap);\n    }\n\n    cachedMap.set(realmObj._objectKey(), value);\n  }; // Adds to cache when serializing an object for toJSON\n\n\n  const getFromCache = (cache, realmObj) => {\n    const tableKey = realmObj._tableKey();\n\n    let cachedMap = cache.get(tableKey);\n    return cachedMap ? cachedMap.get(realmObj._objectKey()) : undefined;\n  };\n\n  Object.defineProperty(realmConstructor.Collection.prototype, \"toJSON\", {\n    value: function toJSON(_) {\n      let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n      return this.map((item, index) => item instanceof realmConstructor.Object ? item.toJSON(index.toString(), cache) : item);\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n  Object.defineProperty(realmConstructor.Dictionary.prototype, \"toJSON\", {\n    value: function toJSON(_) {\n      let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n      const result = {};\n\n      for (const k of this._keys()) {\n        const v = this.getter(k);\n        result[k] = v instanceof realmConstructor.Object ? v.toJSON(k, cache) : v;\n      }\n\n      return result;\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n  Object.defineProperty(realmConstructor.Object.prototype, \"toJSON\", {\n    value: function (_) {\n      let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n      // Check if current objectId has already processed, to keep object references the same.\n      const existing = getFromCache(cache, this);\n\n      if (existing) {\n        return existing;\n      } // Create new result, and store in cache.\n\n\n      const result = {};\n      addToCache(cache, this, result); // Move all enumerable keys to result, triggering any specific toJSON implementation in the process.\n\n      Object.keys(this).concat(Object.keys(Object.getPrototypeOf(this))).forEach(key => {\n        const value = this[key]; // skip any functions & constructors (in case of class models).\n\n        if (typeof value === \"function\") {\n          return; // continue\n        }\n\n        if (value === null || value === undefined) {\n          result[key] = value;\n        } else if (value instanceof realmConstructor.Object || value instanceof realmConstructor.Collection) {\n          // recursively trigger `toJSON` for Realm instances with the same cache.\n          result[key] = value.toJSON(key, cache);\n        } else if (value instanceof realmConstructor.Dictionary || // Allows us to detect if this is a proxied Dictionary on JSC pre-v11. See realm-common/symbols.ts for details.\n        value[symbols.IS_PROXIED_DICTIONARY]) {\n          // Dictionary special case to share the \"cache\" for dictionary-values,\n          // in case of circular structures involving links.\n          result[key] = Object.fromEntries(Object.entries(value).map(_ref => {\n            let [k, v] = _ref;\n            return [k, v instanceof realmConstructor.Object ? v.toJSON(k, cache) : v];\n          }));\n        } else {\n          result[key] = value;\n        }\n      });\n      return result;\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n  Object.defineProperty(realmConstructor.Object.prototype, \"keys\", {\n    value: function () {\n      return Object.keys(this).concat(Object.keys(Object.getPrototypeOf(this)));\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  });\n  Object.defineProperty(realmConstructor.Object.prototype, \"entries\", {\n    value: function () {\n      let result = {};\n\n      for (const key in this) {\n        result[key] = this[key];\n      }\n\n      return Object.entries(result);\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false\n  }); //Add static methods to the Realm object\n\n  Object.defineProperties(realmConstructor, getOwnPropertyDescriptors({\n    open(config) {\n      // If no config is defined, we should just open the default realm\n      if (config === undefined) {\n        config = {};\n      } // For local Realms we open the Realm and return it in a resolved Promise.\n\n\n      if (config.sync === undefined) {\n        return openLocalRealm(realmConstructor, config);\n      }\n\n      const realmExists = realmConstructor.exists(config); // Determine if we are opening an existing Realm or not.\n\n      let behavior = realmExists ? \"existingRealmFileBehavior\" : \"newRealmFileBehavior\"; // Define how the Realm file is opened\n\n      let openLocalRealmImmediately = false; // Default is downloadBeforeOpen\n\n      if (config.sync[behavior] !== undefined) {\n        const type = config.sync[behavior].type;\n\n        switch (type) {\n          case \"downloadBeforeOpen\":\n            openLocalRealmImmediately = false;\n            break;\n\n          case \"openImmediately\":\n            openLocalRealmImmediately = true;\n            break;\n\n          default:\n            throw Error(`Invalid type: '${type}'. Only 'downloadBeforeOpen' and 'openImmediately' is allowed.`);\n        }\n      } // If configured to do so, the synchronized Realm will be opened locally immediately.\n      // If this is the first time the Realm is created, the schema will be created locally as well.\n\n\n      if (openLocalRealmImmediately) {\n        return openLocalRealm(realmConstructor, config);\n      } // Otherwise attempt to synchronize the Realm state from the server before opening it.\n      // First configure any timeOut and corresponding behavior.\n\n\n      let openPromises = []; // Id of the timer triggering the timeout\n\n      let timeoutId = null;\n\n      if (config.sync[behavior] !== undefined && config.sync[behavior].timeOut !== undefined) {\n        let timeOut = config.sync[behavior].timeOut;\n\n        if (typeof timeOut !== \"number\") {\n          throw new Error(`'timeOut' must be a number: '${timeOut}'`);\n        } // Define the behavior in case of a timeout\n\n\n        let throwOnTimeOut = true; // Default is to throw\n\n        if (config.sync[behavior] !== undefined && config.sync[behavior].timeOutBehavior) {\n          const timeOutBehavior = config.sync[behavior].timeOutBehavior;\n\n          switch (timeOutBehavior) {\n            case \"throwException\":\n              throwOnTimeOut = true;\n              break;\n\n            case \"openLocalRealm\":\n              throwOnTimeOut = false;\n              break;\n\n            default:\n              throw Error(`Invalid 'timeOutBehavior': '${timeOutBehavior}'. Only 'throwException' and 'openLocalRealm' is allowed.`);\n          }\n        }\n\n        openPromises.push(new Promise((resolve, reject) => {\n          timeoutId = setTimeout(() => {\n            if (asyncOpenTask) {\n              asyncOpenTask.cancel();\n              asyncOpenTask = null;\n            }\n\n            if (throwOnTimeOut) {\n              reject(new Error(`${config.sync.url} could not be downloaded in the allocated time: ${timeOut} ms.`));\n            } else {\n              return resolve(openLocalRealm(realmConstructor, config));\n            }\n          }, timeOut);\n        }));\n      } // Configure promise responsible for downloading the Realm from the server\n\n\n      let asyncOpenTask;\n      let cancelled = false;\n      openPromises.push(new Promise((resolve, reject) => {\n        asyncOpenTask = realmConstructor._asyncOpen(config, (realm, error) => {\n          setTimeout(() => {\n            asyncOpenTask = null; // The user may have cancelled the open between when\n            // the download completed and when we managed to\n            // actually invoke this, so recheck here.\n\n            if (cancelled) {\n              return;\n            } // Clear the fallback timeOut if it has been started\n\n\n            clearTimeout(timeoutId);\n\n            if (error) {\n              reject(error);\n            } else {\n              resolve(realm);\n            }\n          }, 0);\n        });\n      })); // Return wrapped promises, allowing the users to control them. Once one of the\n      // `openPromise`s has resolved, we may need to wait for initial subscriptions\n      // (if any) to be synchronised, so we return a chained promise to do this.\n\n      let openPromise = Promise.race(openPromises).then(realm => {\n        const {\n          initialSubscriptions\n        } = config.sync; // If `initialSubscriptions` was not specified, return the Realm immediately\n\n        if (!initialSubscriptions) {\n          return realm;\n        } // If an update has been run by C++ (which performs all the validation\n        // and runs the actual update function, see `handle_initial_subscriptions`\n        // in `js_realm.hpp`), we need to return a promise which waits for the\n        // new subscriptions to be fully synchronised, then returns the Realm.\n\n\n        if (initialSubscriptions.rerunOnOpen || !realmExists) {\n          return realm.subscriptions.waitForSynchronization().then(() => {\n            return realm;\n          });\n        } else {\n          return realm;\n        }\n      });\n\n      openPromise.cancel = () => {\n        if (asyncOpenTask) {\n          asyncOpenTask.cancel();\n          cancelled = true;\n        }\n      };\n\n      openPromise.progress = callback => {\n        if (asyncOpenTask) {\n          asyncOpenTask.addDownloadNotification(callback);\n        }\n\n        return openPromise;\n      };\n\n      return openPromise;\n    },\n\n    createTemplateObject(objectSchema) {\n      let obj = {};\n\n      for (let key in objectSchema.properties) {\n        let type;\n\n        if (typeof objectSchema.properties[key] === \"string\" || objectSchema.properties[key] instanceof String) {\n          // Simple declaration of the type\n          type = objectSchema.properties[key];\n        } else {\n          // Advanced property setup\n          const property = objectSchema.properties[key]; // if optional is set, it wil take precedence over any `?` set on the type parameter\n\n          if (property.optional === true) {\n            continue;\n          } // If a default value is explicitly set, always set the property\n\n\n          if (property.default !== undefined) {\n            obj[key] = property.default;\n            continue;\n          }\n\n          type = property.type;\n        } // Set the default value for all required primitive types.\n        // Lists are always treated as empty if not specified and references to objects are always optional\n\n\n        switch (type) {\n          case \"bool\":\n            obj[key] = false;\n            break;\n\n          case \"int\":\n            obj[key] = 0;\n            break;\n\n          case \"float\":\n            obj[key] = 0.0;\n            break;\n\n          case \"double\":\n            obj[key] = 0.0;\n            break;\n\n          case \"string\":\n            obj[key] = \"\";\n            break;\n\n          case \"data\":\n            obj[key] = new ArrayBuffer(0);\n            break;\n\n          case \"date\":\n            obj[key] = new Date(0);\n            break;\n        }\n      }\n\n      return obj;\n    }\n\n  })); // Add static properties to Realm Object\n\n  const updateModeType = {\n    All: \"all\",\n    Modified: \"modified\",\n    Never: \"never\"\n  };\n\n  if (!realmConstructor.UpdateMode) {\n    Object.defineProperty(realmConstructor, \"UpdateMode\", {\n      value: updateModeType,\n      configurable: false\n    });\n  } // Add sync methods\n\n\n  if (realmConstructor.App.Sync) {\n    let appMethods = require(\"./app\");\n\n    Object.defineProperties(realmConstructor.App, getOwnPropertyDescriptors(appMethods.static));\n    Object.defineProperties(realmConstructor.App.prototype, getOwnPropertyDescriptors(appMethods.instance));\n\n    let userMethods = require(\"./user\");\n\n    Object.defineProperties(realmConstructor.User, getOwnPropertyDescriptors(userMethods.static));\n    Object.defineProperties(realmConstructor.User.prototype, getOwnPropertyDescriptors(userMethods.instance));\n\n    let subscriptionSetMethods = require(\"./subscription-set\");\n\n    Object.defineProperties(realmConstructor.App.Sync.SubscriptionSet, getOwnPropertyDescriptors(subscriptionSetMethods.static));\n    Object.defineProperties(realmConstructor.App.Sync.SubscriptionSet.prototype, { ...getOwnPropertyDescriptors(subscriptionSetMethods.instance),\n      ...require(\"./collection-methods\")(realmConstructor)\n    });\n\n    let mutableSubscriptionSetMethods = require(\"./mutable-subscription-set\");\n\n    Object.defineProperties(realmConstructor.App.Sync.MutableSubscriptionSet, getOwnPropertyDescriptors(mutableSubscriptionSetMethods.static));\n    Object.defineProperties(realmConstructor.App.Sync.MutableSubscriptionSet.prototype, { ...getOwnPropertyDescriptors(mutableSubscriptionSetMethods.instance)\n    });\n\n    let sessionMethods = require(\"./session\");\n\n    Object.defineProperties(realmConstructor.App.Sync.Session, getOwnPropertyDescriptors(sessionMethods.static));\n    Object.defineProperties(realmConstructor.App.Sync.Session.prototype, getOwnPropertyDescriptors(sessionMethods.instance));\n\n    let credentialMethods = require(\"./credentials\");\n\n    Object.defineProperties(realmConstructor.Credentials, getOwnPropertyDescriptors(credentialMethods.static));\n\n    let emailPasswordAuthMethods = require(\"./email-password-auth-methods\");\n\n    Object.defineProperties(realmConstructor.Auth.EmailPasswordAuth.prototype, getOwnPropertyDescriptors(emailPasswordAuthMethods.instance));\n\n    let apiKeyAuthMethods = require(\"./api-key-auth-methods\");\n\n    Object.defineProperties(realmConstructor.Auth.ApiKeyAuth.prototype, getOwnPropertyDescriptors(apiKeyAuthMethods.instance));\n    realmConstructor.App.Sync.AuthError = require(\"./errors\").AuthError;\n\n    if (realmConstructor.App.Sync.removeAllListeners) {\n      process.on(\"exit\", realmConstructor.App.Sync.removeAllListeners);\n      process.on(\"SIGINT\", function () {\n        realmConstructor.App.Sync.removeAllListeners();\n        process.exit(2);\n      });\n      process.on(\"uncaughtException\", function (e) {\n        realmConstructor.App.Sync.removeAllListeners();\n        /* eslint-disable no-console */\n\n        console.log(e.stack);\n        process.exit(99);\n      });\n    }\n\n    setConstructorOnPrototype(realmConstructor.User);\n    setConstructorOnPrototype(realmConstructor.App.Sync.Session);\n    setConstructorOnPrototype(realmConstructor.App);\n    setConstructorOnPrototype(realmConstructor.Credentials);\n    realmConstructor.SessionStopPolicy = {\n      AfterUpload: \"after-upload\",\n      Immediately: \"immediately\",\n      Never: \"never\"\n    };\n    realmConstructor.ClientResetMode = {\n      Manual: \"manual\",\n      DiscardLocal: \"discardLocal\"\n    };\n    realmConstructor.App.Sync.openLocalRealmBehavior = {\n      type: \"openImmediately\"\n    };\n    realmConstructor.App.Sync.downloadBeforeOpenBehavior = {\n      type: \"downloadBeforeOpen\",\n      timeOut: 30 * 1000,\n      timeOutBehavior: \"throwException\"\n    };\n    realmConstructor.App.Sync.ConnectionState = {\n      Disconnected: \"disconnected\",\n      Connecting: \"connecting\",\n      Connected: \"connected\"\n    };\n    realmConstructor.App.Sync.SessionState = {\n      Invalid: \"invalid\",\n      Active: \"active\",\n      Inactive: \"inactive\"\n    };\n    realmConstructor.App.Sync.ProgressDirection = {\n      Download: \"download\",\n      Upload: \"upload\"\n    };\n    realmConstructor.App.Sync.ProgressMode = {\n      ReportIndefinitely: \"reportIndefinitely\",\n      ForCurrentlyOutstandingWork: \"forCurrentlyOutstandingWork\"\n    };\n    realmConstructor.App.Sync.ClientResyncMode = {\n      Discard: \"discard\",\n      Manual: \"manual\",\n      Recover: \"recover\"\n    };\n    realmConstructor.App.Sync.SubscriptionsState = {\n      Pending: \"pending\",\n      Complete: \"complete\",\n      Error: \"error\",\n      Superseded: \"superseded\"\n    };\n  } // TODO: Remove this now useless object.\n\n\n  var types = Object.freeze({\n    BOOL: \"bool\",\n    INT: \"int\",\n    FLOAT: \"float\",\n    DOUBLE: \"double\",\n    STRING: \"string\",\n    DATE: \"date\",\n    DATA: \"data\",\n    OBJECT: \"object\",\n    LIST: \"list\"\n  });\n  Object.defineProperty(realmConstructor, \"Types\", {\n    get: function () {\n      if (typeof console != \"undefined\") {\n        /* eslint-disable no-console */\n        var stack = new Error().stack.split(\"\\n\").slice(2).join(\"\\n\");\n        var msg = \"`Realm.Types` is deprecated! Please specify the type name as lowercase string instead!\\n\" + stack;\n\n        if (console.warn != undefined) {\n          console.warn(msg);\n        } else {\n          console.log(msg);\n        }\n        /* eslint-enable no-console */\n\n      }\n\n      return types;\n    },\n    configurable: true\n  });\n};","map":{"version":3,"names":["symbols","require","getOwnPropertyDescriptors","Object","obj","getOwnPropertyNames","reduce","descriptors","name","getOwnPropertyDescriptor","setConstructorOnPrototype","klass","prototype","constructor","defineProperty","value","configurable","writable","openLocalRealm","realmConstructor","config","promise","Promise","resolve","progress","cancel","module","exports","defineProperties","Set","Collection","DictionaryProxy","List","Results","BSON","_Decimal128","Decimal128","_ObjectId","ObjectId","_UUID","UUID","DefaultNetworkTransport","_networkTransport","addToCache","cache","realmObj","tableKey","_tableKey","cachedMap","get","Map","set","_objectKey","getFromCache","undefined","toJSON","_","map","item","index","toString","enumerable","Dictionary","result","k","_keys","v","getter","existing","keys","concat","getPrototypeOf","forEach","key","IS_PROXIED_DICTIONARY","fromEntries","entries","open","sync","realmExists","exists","behavior","openLocalRealmImmediately","type","Error","openPromises","timeoutId","timeOut","throwOnTimeOut","timeOutBehavior","push","reject","setTimeout","asyncOpenTask","url","cancelled","_asyncOpen","realm","error","clearTimeout","openPromise","race","then","initialSubscriptions","rerunOnOpen","subscriptions","waitForSynchronization","callback","addDownloadNotification","createTemplateObject","objectSchema","properties","String","property","optional","default","ArrayBuffer","Date","updateModeType","All","Modified","Never","UpdateMode","App","Sync","appMethods","static","instance","userMethods","User","subscriptionSetMethods","SubscriptionSet","mutableSubscriptionSetMethods","MutableSubscriptionSet","sessionMethods","Session","credentialMethods","Credentials","emailPasswordAuthMethods","Auth","EmailPasswordAuth","apiKeyAuthMethods","ApiKeyAuth","AuthError","removeAllListeners","process","on","exit","e","console","log","stack","SessionStopPolicy","AfterUpload","Immediately","ClientResetMode","Manual","DiscardLocal","openLocalRealmBehavior","downloadBeforeOpenBehavior","ConnectionState","Disconnected","Connecting","Connected","SessionState","Invalid","Active","Inactive","ProgressDirection","Download","Upload","ProgressMode","ReportIndefinitely","ForCurrentlyOutstandingWork","ClientResyncMode","Discard","Recover","SubscriptionsState","Pending","Complete","Superseded","types","freeze","BOOL","INT","FLOAT","DOUBLE","STRING","DATE","DATA","OBJECT","LIST","split","slice","join","msg","warn"],"sources":["/Users/sandeepjain/mongoauth/node_modules/realm/lib/extensions.js"],"sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2021 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\nconst { symbols } = require(\"@realm/common\");\n\nlet getOwnPropertyDescriptors =\n  Object.getOwnPropertyDescriptors ||\n  function (obj) {\n    return Object.getOwnPropertyNames(obj).reduce(function (descriptors, name) {\n      descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);\n      return descriptors;\n    }, {});\n  };\n\nfunction setConstructorOnPrototype(klass) {\n  if (klass.prototype.constructor !== klass) {\n    Object.defineProperty(klass.prototype, \"constructor\", { value: klass, configurable: true, writable: true });\n  }\n}\n\nfunction openLocalRealm(realmConstructor, config) {\n  let promise = Promise.resolve(new realmConstructor(config));\n  promise.progress = () => {\n    return promise;\n  };\n  promise.cancel = () => {};\n  return promise;\n}\n\nmodule.exports = function (realmConstructor) {\n  // Add the specified Array methods to the Collection prototype.\n  Object.defineProperties(realmConstructor.Set.prototype, require(\"./set-methods\")(realmConstructor));\n  Object.defineProperties(realmConstructor.Collection.prototype, require(\"./collection-methods\")(realmConstructor));\n  realmConstructor.DictionaryProxy = require(\"./dictionary\").DictionaryProxy;\n\n  setConstructorOnPrototype(realmConstructor.Collection);\n  setConstructorOnPrototype(realmConstructor.List);\n  setConstructorOnPrototype(realmConstructor.Results);\n  setConstructorOnPrototype(realmConstructor.Object);\n  setConstructorOnPrototype(realmConstructor.Set);\n  setConstructorOnPrototype(realmConstructor.DictionaryProxy);\n\n  realmConstructor.BSON = require(\"bson\");\n  realmConstructor._Decimal128 = realmConstructor.BSON.Decimal128;\n  realmConstructor._ObjectId = realmConstructor.BSON.ObjectId;\n  realmConstructor._UUID = realmConstructor.BSON.UUID;\n  const { DefaultNetworkTransport } = require(\"@realm/network-transport\");\n  realmConstructor._networkTransport = new DefaultNetworkTransport();\n\n  // Adds to cache when serializing an object for toJSON\n  const addToCache = (cache, realmObj, value) => {\n    const tableKey = realmObj._tableKey();\n    let cachedMap = cache.get(tableKey);\n    if (!cachedMap) {\n      cachedMap = new Map();\n      cache.set(tableKey, cachedMap);\n    }\n    cachedMap.set(realmObj._objectKey(), value);\n  };\n\n  // Adds to cache when serializing an object for toJSON\n  const getFromCache = (cache, realmObj) => {\n    const tableKey = realmObj._tableKey();\n    let cachedMap = cache.get(tableKey);\n    return cachedMap ? cachedMap.get(realmObj._objectKey()) : undefined;\n  };\n\n  Object.defineProperty(realmConstructor.Collection.prototype, \"toJSON\", {\n    value: function toJSON(_, cache = new Map()) {\n      return this.map((item, index) =>\n        item instanceof realmConstructor.Object ? item.toJSON(index.toString(), cache) : item,\n      );\n    },\n\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  });\n\n  Object.defineProperty(realmConstructor.Dictionary.prototype, \"toJSON\", {\n    value: function toJSON(_, cache = new Map()) {\n      const result = {};\n      for (const k of this._keys()) {\n        const v = this.getter(k);\n        result[k] = v instanceof realmConstructor.Object ? v.toJSON(k, cache) : v;\n      }\n      return result;\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  });\n\n  Object.defineProperty(realmConstructor.Object.prototype, \"toJSON\", {\n    value: function (_, cache = new Map()) {\n      // Check if current objectId has already processed, to keep object references the same.\n      const existing = getFromCache(cache, this);\n      if (existing) {\n        return existing;\n      }\n\n      // Create new result, and store in cache.\n      const result = {};\n      addToCache(cache, this, result);\n\n      // Move all enumerable keys to result, triggering any specific toJSON implementation in the process.\n      Object.keys(this)\n        .concat(Object.keys(Object.getPrototypeOf(this)))\n        .forEach((key) => {\n          const value = this[key];\n\n          // skip any functions & constructors (in case of class models).\n          if (typeof value === \"function\") {\n            return; // continue\n          }\n\n          if (value === null || value === undefined) {\n            result[key] = value;\n          } else if (value instanceof realmConstructor.Object || value instanceof realmConstructor.Collection) {\n            // recursively trigger `toJSON` for Realm instances with the same cache.\n            result[key] = value.toJSON(key, cache);\n          } else if (\n            value instanceof realmConstructor.Dictionary ||\n            // Allows us to detect if this is a proxied Dictionary on JSC pre-v11. See realm-common/symbols.ts for details.\n            value[symbols.IS_PROXIED_DICTIONARY]\n          ) {\n            // Dictionary special case to share the \"cache\" for dictionary-values,\n            // in case of circular structures involving links.\n            result[key] = Object.fromEntries(\n              Object.entries(value).map(([k, v]) => [k, v instanceof realmConstructor.Object ? v.toJSON(k, cache) : v]),\n            );\n          } else {\n            result[key] = value;\n          }\n        });\n\n      return result;\n    },\n\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  });\n\n  Object.defineProperty(realmConstructor.Object.prototype, \"keys\", {\n    value: function () {\n      return Object.keys(this).concat(Object.keys(Object.getPrototypeOf(this)));\n    },\n\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  });\n\n  Object.defineProperty(realmConstructor.Object.prototype, \"entries\", {\n    value: function () {\n      let result = {};\n      for (const key in this) {\n        result[key] = this[key];\n      }\n\n      return Object.entries(result);\n    },\n\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  });\n\n  //Add static methods to the Realm object\n  Object.defineProperties(\n    realmConstructor,\n    getOwnPropertyDescriptors({\n      open(config) {\n        // If no config is defined, we should just open the default realm\n        if (config === undefined) {\n          config = {};\n        }\n\n        // For local Realms we open the Realm and return it in a resolved Promise.\n        if (config.sync === undefined) {\n          return openLocalRealm(realmConstructor, config);\n        }\n\n        const realmExists = realmConstructor.exists(config);\n\n        // Determine if we are opening an existing Realm or not.\n        let behavior = realmExists ? \"existingRealmFileBehavior\" : \"newRealmFileBehavior\";\n\n        // Define how the Realm file is opened\n        let openLocalRealmImmediately = false; // Default is downloadBeforeOpen\n        if (config.sync[behavior] !== undefined) {\n          const type = config.sync[behavior].type;\n          switch (type) {\n            case \"downloadBeforeOpen\":\n              openLocalRealmImmediately = false;\n              break;\n            case \"openImmediately\":\n              openLocalRealmImmediately = true;\n              break;\n            default:\n              throw Error(`Invalid type: '${type}'. Only 'downloadBeforeOpen' and 'openImmediately' is allowed.`);\n          }\n        }\n\n        // If configured to do so, the synchronized Realm will be opened locally immediately.\n        // If this is the first time the Realm is created, the schema will be created locally as well.\n        if (openLocalRealmImmediately) {\n          return openLocalRealm(realmConstructor, config);\n        }\n\n        // Otherwise attempt to synchronize the Realm state from the server before opening it.\n\n        // First configure any timeOut and corresponding behavior.\n        let openPromises = [];\n\n        // Id of the timer triggering the timeout\n        let timeoutId = null;\n\n        if (config.sync[behavior] !== undefined && config.sync[behavior].timeOut !== undefined) {\n          let timeOut = config.sync[behavior].timeOut;\n          if (typeof timeOut !== \"number\") {\n            throw new Error(`'timeOut' must be a number: '${timeOut}'`);\n          }\n\n          // Define the behavior in case of a timeout\n          let throwOnTimeOut = true; // Default is to throw\n          if (config.sync[behavior] !== undefined && config.sync[behavior].timeOutBehavior) {\n            const timeOutBehavior = config.sync[behavior].timeOutBehavior;\n            switch (timeOutBehavior) {\n              case \"throwException\":\n                throwOnTimeOut = true;\n                break;\n              case \"openLocalRealm\":\n                throwOnTimeOut = false;\n                break;\n              default:\n                throw Error(\n                  `Invalid 'timeOutBehavior': '${timeOutBehavior}'. Only 'throwException' and 'openLocalRealm' is allowed.`,\n                );\n            }\n          }\n\n          openPromises.push(\n            new Promise((resolve, reject) => {\n              timeoutId = setTimeout(() => {\n                if (asyncOpenTask) {\n                  asyncOpenTask.cancel();\n                  asyncOpenTask = null;\n                }\n                if (throwOnTimeOut) {\n                  reject(new Error(`${config.sync.url} could not be downloaded in the allocated time: ${timeOut} ms.`));\n                } else {\n                  return resolve(openLocalRealm(realmConstructor, config));\n                }\n              }, timeOut);\n            }),\n          );\n        }\n\n        // Configure promise responsible for downloading the Realm from the server\n        let asyncOpenTask;\n        let cancelled = false;\n        openPromises.push(\n          new Promise((resolve, reject) => {\n            asyncOpenTask = realmConstructor._asyncOpen(config, (realm, error) => {\n              setTimeout(() => {\n                asyncOpenTask = null;\n                // The user may have cancelled the open between when\n                // the download completed and when we managed to\n                // actually invoke this, so recheck here.\n                if (cancelled) {\n                  return;\n                }\n                // Clear the fallback timeOut if it has been started\n                clearTimeout(timeoutId);\n                if (error) {\n                  reject(error);\n                } else {\n                  resolve(realm);\n                }\n              }, 0);\n            });\n          }),\n        );\n\n        // Return wrapped promises, allowing the users to control them. Once one of the\n        // `openPromise`s has resolved, we may need to wait for initial subscriptions\n        // (if any) to be synchronised, so we return a chained promise to do this.\n        let openPromise = Promise.race(openPromises).then((realm) => {\n          const { initialSubscriptions } = config.sync;\n\n          // If `initialSubscriptions` was not specified, return the Realm immediately\n          if (!initialSubscriptions) {\n            return realm;\n          }\n\n          // If an update has been run by C++ (which performs all the validation\n          // and runs the actual update function, see `handle_initial_subscriptions`\n          // in `js_realm.hpp`), we need to return a promise which waits for the\n          // new subscriptions to be fully synchronised, then returns the Realm.\n          if (initialSubscriptions.rerunOnOpen || !realmExists) {\n            return realm.subscriptions.waitForSynchronization().then(() => {\n              return realm;\n            });\n          } else {\n            return realm;\n          }\n        });\n\n        openPromise.cancel = () => {\n          if (asyncOpenTask) {\n            asyncOpenTask.cancel();\n            cancelled = true;\n          }\n        };\n        openPromise.progress = (callback) => {\n          if (asyncOpenTask) {\n            asyncOpenTask.addDownloadNotification(callback);\n          }\n          return openPromise;\n        };\n        return openPromise;\n      },\n\n      createTemplateObject(objectSchema) {\n        let obj = {};\n        for (let key in objectSchema.properties) {\n          let type;\n          if (typeof objectSchema.properties[key] === \"string\" || objectSchema.properties[key] instanceof String) {\n            // Simple declaration of the type\n            type = objectSchema.properties[key];\n          } else {\n            // Advanced property setup\n            const property = objectSchema.properties[key];\n\n            // if optional is set, it wil take precedence over any `?` set on the type parameter\n            if (property.optional === true) {\n              continue;\n            }\n\n            // If a default value is explicitly set, always set the property\n            if (property.default !== undefined) {\n              obj[key] = property.default;\n              continue;\n            }\n\n            type = property.type;\n          }\n\n          // Set the default value for all required primitive types.\n          // Lists are always treated as empty if not specified and references to objects are always optional\n          switch (type) {\n            case \"bool\":\n              obj[key] = false;\n              break;\n            case \"int\":\n              obj[key] = 0;\n              break;\n            case \"float\":\n              obj[key] = 0.0;\n              break;\n            case \"double\":\n              obj[key] = 0.0;\n              break;\n            case \"string\":\n              obj[key] = \"\";\n              break;\n            case \"data\":\n              obj[key] = new ArrayBuffer(0);\n              break;\n            case \"date\":\n              obj[key] = new Date(0);\n              break;\n          }\n        }\n        return obj;\n      },\n    }),\n  );\n\n  // Add static properties to Realm Object\n  const updateModeType = {\n    All: \"all\",\n    Modified: \"modified\",\n    Never: \"never\",\n  };\n\n  if (!realmConstructor.UpdateMode) {\n    Object.defineProperty(realmConstructor, \"UpdateMode\", {\n      value: updateModeType,\n      configurable: false,\n    });\n  }\n\n  // Add sync methods\n  if (realmConstructor.App.Sync) {\n    let appMethods = require(\"./app\");\n    Object.defineProperties(realmConstructor.App, getOwnPropertyDescriptors(appMethods.static));\n    Object.defineProperties(realmConstructor.App.prototype, getOwnPropertyDescriptors(appMethods.instance));\n\n    let userMethods = require(\"./user\");\n    Object.defineProperties(realmConstructor.User, getOwnPropertyDescriptors(userMethods.static));\n    Object.defineProperties(realmConstructor.User.prototype, getOwnPropertyDescriptors(userMethods.instance));\n\n    let subscriptionSetMethods = require(\"./subscription-set\");\n    Object.defineProperties(\n      realmConstructor.App.Sync.SubscriptionSet,\n      getOwnPropertyDescriptors(subscriptionSetMethods.static),\n    );\n    Object.defineProperties(realmConstructor.App.Sync.SubscriptionSet.prototype, {\n      ...getOwnPropertyDescriptors(subscriptionSetMethods.instance),\n      ...require(\"./collection-methods\")(realmConstructor),\n    });\n\n    let mutableSubscriptionSetMethods = require(\"./mutable-subscription-set\");\n    Object.defineProperties(\n      realmConstructor.App.Sync.MutableSubscriptionSet,\n      getOwnPropertyDescriptors(mutableSubscriptionSetMethods.static),\n    );\n    Object.defineProperties(realmConstructor.App.Sync.MutableSubscriptionSet.prototype, {\n      ...getOwnPropertyDescriptors(mutableSubscriptionSetMethods.instance),\n    });\n\n    let sessionMethods = require(\"./session\");\n    Object.defineProperties(realmConstructor.App.Sync.Session, getOwnPropertyDescriptors(sessionMethods.static));\n    Object.defineProperties(\n      realmConstructor.App.Sync.Session.prototype,\n      getOwnPropertyDescriptors(sessionMethods.instance),\n    );\n\n    let credentialMethods = require(\"./credentials\");\n    Object.defineProperties(realmConstructor.Credentials, getOwnPropertyDescriptors(credentialMethods.static));\n\n    let emailPasswordAuthMethods = require(\"./email-password-auth-methods\");\n    Object.defineProperties(\n      realmConstructor.Auth.EmailPasswordAuth.prototype,\n      getOwnPropertyDescriptors(emailPasswordAuthMethods.instance),\n    );\n\n    let apiKeyAuthMethods = require(\"./api-key-auth-methods\");\n    Object.defineProperties(\n      realmConstructor.Auth.ApiKeyAuth.prototype,\n      getOwnPropertyDescriptors(apiKeyAuthMethods.instance),\n    );\n\n    realmConstructor.App.Sync.AuthError = require(\"./errors\").AuthError;\n\n    if (realmConstructor.App.Sync.removeAllListeners) {\n      process.on(\"exit\", realmConstructor.App.Sync.removeAllListeners);\n      process.on(\"SIGINT\", function () {\n        realmConstructor.App.Sync.removeAllListeners();\n        process.exit(2);\n      });\n      process.on(\"uncaughtException\", function (e) {\n        realmConstructor.App.Sync.removeAllListeners();\n        /* eslint-disable no-console */\n        console.log(e.stack);\n        process.exit(99);\n      });\n    }\n\n    setConstructorOnPrototype(realmConstructor.User);\n    setConstructorOnPrototype(realmConstructor.App.Sync.Session);\n    setConstructorOnPrototype(realmConstructor.App);\n    setConstructorOnPrototype(realmConstructor.Credentials);\n\n    realmConstructor.SessionStopPolicy = {\n      AfterUpload: \"after-upload\",\n      Immediately: \"immediately\",\n      Never: \"never\",\n    };\n\n    realmConstructor.ClientResetMode = {\n      Manual: \"manual\",\n      DiscardLocal: \"discardLocal\",\n    };\n\n    realmConstructor.App.Sync.openLocalRealmBehavior = {\n      type: \"openImmediately\",\n    };\n\n    realmConstructor.App.Sync.downloadBeforeOpenBehavior = {\n      type: \"downloadBeforeOpen\",\n      timeOut: 30 * 1000,\n      timeOutBehavior: \"throwException\",\n    };\n\n    realmConstructor.App.Sync.ConnectionState = {\n      Disconnected: \"disconnected\",\n      Connecting: \"connecting\",\n      Connected: \"connected\",\n    };\n\n    realmConstructor.App.Sync.SessionState = {\n      Invalid: \"invalid\",\n      Active: \"active\",\n      Inactive: \"inactive\",\n    };\n\n    realmConstructor.App.Sync.ProgressDirection = {\n      Download: \"download\",\n      Upload: \"upload\",\n    };\n\n    realmConstructor.App.Sync.ProgressMode = {\n      ReportIndefinitely: \"reportIndefinitely\",\n      ForCurrentlyOutstandingWork: \"forCurrentlyOutstandingWork\",\n    };\n\n    realmConstructor.App.Sync.ClientResyncMode = {\n      Discard: \"discard\",\n      Manual: \"manual\",\n      Recover: \"recover\",\n    };\n\n    realmConstructor.App.Sync.SubscriptionsState = {\n      Pending: \"pending\",\n      Complete: \"complete\",\n      Error: \"error\",\n      Superseded: \"superseded\",\n    };\n  }\n\n  // TODO: Remove this now useless object.\n  var types = Object.freeze({\n    BOOL: \"bool\",\n    INT: \"int\",\n    FLOAT: \"float\",\n    DOUBLE: \"double\",\n    STRING: \"string\",\n    DATE: \"date\",\n    DATA: \"data\",\n    OBJECT: \"object\",\n    LIST: \"list\",\n  });\n  Object.defineProperty(realmConstructor, \"Types\", {\n    get: function () {\n      if (typeof console != \"undefined\") {\n        /* eslint-disable no-console */\n        var stack = new Error().stack.split(\"\\n\").slice(2).join(\"\\n\");\n        var msg = \"`Realm.Types` is deprecated! Please specify the type name as lowercase string instead!\\n\" + stack;\n        if (console.warn != undefined) {\n          console.warn(msg);\n        } else {\n          console.log(msg);\n        }\n        /* eslint-enable no-console */\n      }\n      return types;\n    },\n    configurable: true,\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}