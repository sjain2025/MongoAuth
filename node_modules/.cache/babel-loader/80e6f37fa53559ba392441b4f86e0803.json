{"ast":null,"code":"////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2021 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\nmodule.exports = function (realmConstructor) {\n  const exportedFunctions = {};\n  var arrayPrototype = Array.prototype; // eslint-disable-next-line no-undef\n\n  var iteratorPrototype = {}; // These iterators should themselves be iterable.\n\n  Object.defineProperty(iteratorPrototype, Symbol.iterator, {\n    value: function () {\n      return this;\n    }\n  });\n  [\"toString\", \"toLocaleString\", \"concat\", \"join\", \"slice\", \"lastIndexOf\", \"every\", \"some\", \"forEach\", \"find\", \"findIndex\", \"map\", \"filter\", \"reduce\", \"reduceRight\"].forEach(function (methodName) {\n    var method = arrayPrototype[methodName];\n\n    if (method) {\n      exportedFunctions[methodName] = {\n        // XXX this is a temporary solution/hack to work around the fact that Hermes' implementation of Array does not\n        // like it when you call one of its methods bound to a non-array. We were calling them on our Collection types.\n        // This code is just copying the collection to a real array, then calling the method on that. Instead, we should\n        // find a way to operate on the collection directly, possibly by using our own implementation of the array methods,\n        // possibly copied from a polyfill lib. This is particularly bad for things like find() that may not need to look\n        // at the whole collection but we are copying the whole thing anyway.\n        value() {\n          return [...this][methodName](...arguments);\n        },\n\n        configurable: true,\n        writable: true\n      };\n    }\n  });\n  [\"entries\", \"keys\", \"values\"].forEach(function (methodName) {\n    var method = function () {\n      const isSet = this instanceof realmConstructor.Set;\n      var self = this.type === \"object\" || isSet ? this.snapshot() : this;\n      var index = 0;\n      return Object.create(iteratorPrototype, {\n        next: {\n          value: function () {\n            if (!self || index >= self.length) {\n              self = null;\n              return {\n                done: true,\n                value: undefined\n              };\n            }\n\n            var value;\n\n            switch (methodName) {\n              case \"entries\":\n                value = isSet ? [self[index], self[index]] : [index, self[index]];\n                break;\n\n              case \"keys\":\n                value = isSet ? undefined : index;\n                break;\n\n              default:\n                value = self[index];\n                break;\n            }\n\n            index++;\n            return {\n              done: false,\n              value: value\n            };\n          }\n        }\n      });\n    };\n\n    exportedFunctions[methodName] = {\n      value: method,\n      configurable: true,\n      writable: true\n    };\n  });\n  exportedFunctions[Symbol.iterator] = exportedFunctions.values;\n  return exportedFunctions;\n};","map":{"version":3,"names":["module","exports","realmConstructor","exportedFunctions","arrayPrototype","Array","prototype","iteratorPrototype","Object","defineProperty","Symbol","iterator","value","forEach","methodName","method","configurable","writable","isSet","Set","self","type","snapshot","index","create","next","length","done","undefined","values"],"sources":["/Users/sandeepjain/mongoauth/node_modules/realm/lib/collection-methods.js"],"sourcesContent":["////////////////////////////////////////////////////////////////////////////\n//\n// Copyright 2021 Realm Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n////////////////////////////////////////////////////////////////////////////\n\nmodule.exports = function (realmConstructor) {\n  const exportedFunctions = {};\n  var arrayPrototype = Array.prototype;\n  // eslint-disable-next-line no-undef\n  var iteratorPrototype = {};\n\n  // These iterators should themselves be iterable.\n  Object.defineProperty(iteratorPrototype, Symbol.iterator, {\n    value: function () {\n      return this;\n    },\n  });\n\n  [\n    \"toString\",\n    \"toLocaleString\",\n    \"concat\",\n    \"join\",\n    \"slice\",\n    \"lastIndexOf\",\n    \"every\",\n    \"some\",\n    \"forEach\",\n    \"find\",\n    \"findIndex\",\n    \"map\",\n    \"filter\",\n    \"reduce\",\n    \"reduceRight\",\n  ].forEach(function (methodName) {\n    var method = arrayPrototype[methodName];\n    if (method) {\n      exportedFunctions[methodName] = {\n        // XXX this is a temporary solution/hack to work around the fact that Hermes' implementation of Array does not\n        // like it when you call one of its methods bound to a non-array. We were calling them on our Collection types.\n        // This code is just copying the collection to a real array, then calling the method on that. Instead, we should\n        // find a way to operate on the collection directly, possibly by using our own implementation of the array methods,\n        // possibly copied from a polyfill lib. This is particularly bad for things like find() that may not need to look\n        // at the whole collection but we are copying the whole thing anyway.\n        value(...args) {\n          return [...this][methodName](...args);\n        },\n        configurable: true,\n        writable: true,\n      };\n    }\n  });\n\n  [\"entries\", \"keys\", \"values\"].forEach(function (methodName) {\n    var method = function () {\n      const isSet = this instanceof realmConstructor.Set;\n      var self = this.type === \"object\" || isSet ? this.snapshot() : this;\n      var index = 0;\n\n      return Object.create(iteratorPrototype, {\n        next: {\n          value: function () {\n            if (!self || index >= self.length) {\n              self = null;\n              return { done: true, value: undefined };\n            }\n\n            var value;\n            switch (methodName) {\n              case \"entries\":\n                value = isSet ? [self[index], self[index]] : [index, self[index]];\n                break;\n              case \"keys\":\n                value = isSet ? undefined : index;\n                break;\n              default:\n                value = self[index];\n                break;\n            }\n\n            index++;\n            return { done: false, value: value };\n          },\n        },\n      });\n    };\n\n    exportedFunctions[methodName] = { value: method, configurable: true, writable: true };\n  });\n\n  exportedFunctions[Symbol.iterator] = exportedFunctions.values;\n\n  return exportedFunctions;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}